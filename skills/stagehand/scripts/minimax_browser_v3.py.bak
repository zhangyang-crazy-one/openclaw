#!/usr/bin/env python3
"""
MiniMax Browser Automation - Stagehand Architecture

åŸºäº Stagehand æ ¸å¿ƒè®¾è®¡é‡æ„:
1. Hybrid Accessibility Tree (å¯è®¿é—®æ€§æ ‘)
2. Two-Phase Inference (ä¸¤é˜¶æ®µæ¨ç†)
3. Self-Healing (è‡ªæ„ˆèƒ½åŠ›)
4. Shadow DOM ç©¿é€æ”¯æŒ
"""

import asyncio
import json
import os
import re
from typing import Any, Dict, List, Optional

import httpx
from playwright.async_api import async_playwright

from scripts.a11y_tree import AccessibilityTreeBuilder


class MiniMaxBrowserV3:
    """
    åŸºäº Stagehand æ¶æ„çš„æµè§ˆå™¨è‡ªåŠ¨åŒ–.
    
    æ ¸å¿ƒä¼˜åŠ¿:
    - è¯­ä¹‰åŒ–å…ƒç´ å®šä½ (ä¸å— CSS selector å˜åŒ–å½±å“)
    - ä¸¤é˜¶æ®µæ¨ç† (æ‰¾å…ƒç´  â†’ å®šåŠ¨ä½œ)
    - è‡ªæ„ˆèƒ½åŠ› (é¡µé¢æ›´æ–°åè‡ªåŠ¨é€‚é…)
    """
    
    def __init__(
        self,
        model: str = "MiniMax-M2",
        headless: bool = True,
    ):
        self.model = model
        self.headless = headless
        
        # MiniMax é…ç½® - å›½å†…ç‰ˆ
        self.api_key = os.getenv("MINIMAX_API_KEY")
        self.api_base = os.getenv("MINIMAX_API_BASE", "https://api.minimaxi.com/v1")
        
        if not self.api_key:
            raise ValueError("MINIMAX_API_KEY æœªè®¾ç½®")
        
        # ç»„ä»¶
        self.a11y_builder = AccessibilityTreeBuilder()
        
        # çŠ¶æ€
        self.browser = None
        self.context = None
        self.page = None
        self.initialized = False
        
        # ç¼“å­˜
        self._cached_tree: Optional[str] = None
        self._tree_version: int = 0
    
    async def _call_llm(
        self,
        messages: List[Dict],
        max_tokens: int = 4000
    ) -> str:
        """è°ƒç”¨ MiniMax API."""
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json",
        }
        
        payload = {
            "model": self.model,
            "messages": messages,
            "max_tokens": max_tokens,
        }
        
        async with httpx.AsyncClient(timeout=120.0) as client:
            response = await client.post(
                f"{self.api_base}/chat/completions",
                headers=headers,
                json=payload,
            )
            response.raise_for_status()
            return response.json()["choices"][0]["message"]["content"]
    
    def _build_system_prompt(self) -> str:
        """æ„å»ºç³»ç»Ÿæç¤ºè¯."""
        return """You are a professional browser automation assistant.
Your goal is to help users interact with web pages using natural language.

Key principles:
1. Understand user intent from natural language
2. Match elements semantically (not by CSS selectors)
3. Handle dynamic page changes gracefully
4. Provide clear reasoning for your actions

Always respond with valid JSON."""
    
    async def initialize(self) -> Dict[str, Any]:
        """åˆå§‹åŒ–æµè§ˆå™¨."""
        try:
            playwright = await async_playwright().start()
            
            chrome_path = os.getenv("CHROME_PATH") or "/usr/bin/google-chrome"
            
            if os.path.exists(chrome_path):
                self.browser = await playwright.chromium.launch(
                    headless=self.headless,
                    executable_path=chrome_path,
                )
            else:
                self.browser = await playwright.chromium.launch(headless=self.headless)
            
            self.context = await self.browser.new_context()
            self.page = await self.context.new_page()
            self.initialized = True
            
            return {
                "success": True,
                "message": "âœ… æµè§ˆå™¨åˆå§‹åŒ–æˆåŠŸ",
                "architecture": "Stagehand V3",
                "features": [
                    "Hybrid Accessibility Tree",
                    "Two-Phase Inference", 
                    "Self-Healing",
                ]
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def _get_accessibility_tree(self, force_refresh: bool = False) -> str:
        """è·å–é¡µé¢å¯è®¿é—®æ€§æ ‘."""
        if self._cached_tree and not force_refresh:
            return self._cached_tree
        
        self._cached_tree = await self.a11y_builder.build_tree(self.page)
        self._tree_version += 1
        
        return self._cached_tree
    
    async def _execute_action(self, action_plan: Dict) -> bool:
        """æ‰§è¡ŒåŠ¨ä½œ."""
        element_id = action_plan.get("element_id", 0)
        method = action_plan.get("method", "click")
        arguments = action_plan.get("arguments", ["left"])
        
        # è·å–å…ƒç´ 
        tree = await self._get_accessibility_tree()
        lines = tree.split("\n")
        
        if element_id >= len(lines):
            # å°è¯•æ¨¡ç³ŠåŒ¹é…
            return await self._fallback_action(action_plan)
        
        # è·å–å…ƒç´ ä¿¡æ¯
        element_info = await self.page.evaluate(f"""() => {{
            const elements = document.querySelectorAll('a, button, input, select, textarea, [role]');
            if (elements[{element_id}]) {{
                const el = elements[{element_id}];
                return {{
                    tag: el.tagName.toLowerCase(),
                    id: el.id || '',
                    href: el.href || '',
                    text: el.innerText?.trim() || '',
                    selector: el.id ? `#\${{el.id}}` : ''
                }};
            }}
            return null;
        }}""")
        
        if not element_info:
            return await self._fallback_action(action_plan)
        
        # æ‰§è¡ŒåŠ¨ä½œ
        selector = element_info.get("selector", "")
        
        if method == "click":
            if selector:
                await self.page.click(selector)
            else:
                await self.page.evaluate(f"""() => {{
                    const elements = document.querySelectorAll('a, button, [role]');
                    if (elements[{element_id}]) elements[{element_id}].click();
                }}""")
        
        elif method == "fill":
            value = action_plan.get("value", "")
            if selector:
                await self.page.fill(selector, value)
            else:
                await self.page.evaluate(f"""(v) => {{
                    const elements = document.querySelectorAll('input, textarea');
                    if (elements[{element_id}]) elements[{element_id}].value = v;
                }}""", value)
        
        elif method == "hover":
            if selector:
                await self.page.hover(selector)
        
        elif method == "scroll":
            position = action_plan.get("arguments", ["50%"])[0]
            if "%" in position:
                pct = int(position.replace("%", ""))
                await self.page.evaluate(f"""(p) => window.scrollTo(0, document.body.scrollHeight * p / 100)""", pct)
        
        elif method == "press":
            key = action_plan.get("arguments", ["Enter"])[0]
            await self.page.keyboard.press(key)
        
        return True
    
    async def _fallback_action(self, action_plan: Dict) -> bool:
        """å›é€€åŠ¨ä½œ: å°è¯•è¯­ä¹‰åŒ–åŒ¹é…."""
        instruction = action_plan.get("reasoning", "")
        
        # å°è¯•åŸºäºæ–‡æœ¬å†…å®¹ç‚¹å‡»
        if "ç™»å½•" in instruction or "login" in instruction.lower():
            await self.page.click('button:has-text("ç™»å½•"), a:has-text("ç™»å½•"), [role="button"]:has-text("ç™»å½•")')
            return True
        
        if "æäº¤" in instruction or "submit" in instruction.lower():
            await self.page.click('button:has-text("æäº¤"), [type="submit"]')
            return True
        
        # å…œåº•: é¡µé¢ç‚¹å‡»
        return False
    
    async def navigate(self, url: str) -> Dict[str, Any]:
        """å¯¼èˆªåˆ° URL."""
        if not self.initialized:
            return {"success": False, "error": "æµè§ˆå™¨æœªåˆå§‹åŒ–"}
        
        try:
            await self.page.goto(url, wait_until="domcontentloaded")
            
            # è·å–åˆå§‹æ ‘
            await self._get_accessibility_tree(force_refresh=True)
            
            return {
                "success": True,
                "url": url,
                "title": await self.page.title(),
                "tree_version": self._tree_version,
            }
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def act(self, instruction: str) -> Dict[str, Any]:
        """
        æ‰§è¡Œè‡ªç„¶è¯­è¨€æŒ‡ä»¤ - ä¸¤é˜¶æ®µæ¨ç†.
        
        Phase 1: ä» A11y Tree æ‰¾åˆ°åŒ¹é…å…ƒç´ 
        Phase 2: ç¡®å®šæ‰§è¡ŒåŠ¨ä½œ
        """
        if not self.initialized:
            return {"success": False, "error": "æµè§ˆå™¨æœªåˆå§‹åŒ–"}
        
        try:
            # è·å–å¯è®¿é—®æ€§æ ‘
            tree = await self._get_accessibility_tree()
            
            # æ„å»ºæç¤ºè¯ (Phase 1 + Phase 2)
            messages = [
                {"role": "system", "content": self._build_system_prompt()},
                {"role": "user", "content": f"""
=== PHASE 1: FIND ELEMENT ===
ä»ä»¥ä¸‹å¯è®¿é—®æ€§æ ‘ä¸­æ‰¾åˆ°åŒ¹é…æŒ‡ä»¤çš„å…ƒç´ :

{tree}

æŒ‡ä»¤: {instruction}

è¯·åˆ†æå¹¶è¿”å› JSON:
{{
    "element_id": å…ƒç´ ç´¢å¼•(æ•°å­—),
    "element_description": "å…ƒç´ æè¿°",
    "reasoning": "ä¸ºä»€ä¹ˆé€‰æ‹©è¿™ä¸ªå…ƒç´ "
}}

=== PHASE 2: DETERMINE ACTION ===
Based on the instruction and element, determine the action:

æŒ‡ä»¤: {instruction}

å¦‚æœæ˜¯æŒ‡ç¤ºç‚¹å‡»/é€‰æ‹©:
{{
    "element_id": <æ¥è‡ªPhase 1>,
    "method": "click|hover|fill",
    "arguments": ["left" æˆ–å…·ä½“å€¼],
    "reasoning": "è§£é‡Šä¸ºä»€ä¹ˆé€‰æ‹©è¿™ä¸ªåŠ¨ä½œ"
}}

å¦‚æœæ˜¯æŒ‡ç¤ºæ»šåŠ¨:
{{
    "method": "scroll",
    "arguments": ["25%|50%|75%|100%"],
    "reasoning": "æ»šåŠ¨ä½ç½®"
}}

å¦‚æœæ˜¯æŒ‡ç¤ºæŒ‰é”®:
{{
    "method": "press",
    "arguments": ["Enter|Space|ArrowUp|ArrowDown"],
    "reasoning": "æŒ‰é”®åŸå› "
}}

å¦‚æœæ— æ³•åŒ¹é…:
{{"element_id": -1}}
"""}
            ]
            
            response = await self._call_llm(messages)
            
            # è§£æå“åº”
            action_plan = self._parse_llm_response(response)
            
            # æ‰§è¡ŒåŠ¨ä½œ
            success = False
            if action_plan.get("element_id", -1) >= 0:
                success = await self._execute_action(action_plan)
            
            return {
                "success": success,
                "instruction": instruction,
                "action_plan": action_plan,
                "reasoning": action_plan.get("reasoning", ""),
                "tree_version": self._tree_version,
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def _parse_llm_response(self, response: str) -> Dict:
        """è§£æ LLM å“åº”."""
        try:
            # å°è¯• JSON
            return json.loads(response)
        except json.JSONDecodeError:
            # å°è¯•æå– JSON å—
            match = re.search(r'\{[^{}]+\}', response.replace("\n", ""))
            if match:
                try:
                    return json.loads(match.group())
                except json.JSONDecodeError:
                    pass
            
            # å°è¯•æå– element_id
            id_match = re.search(r'"element_id"?:\s*(\d+)', response)
            method_match = re.search(r'"method"?:\s*"([^"]+)"', response)
            
            return {
                "element_id": int(id_match.group(1)) if id_match else 0,
                "method": method_match.group(1) if method_match else "click",
            }
    
    async def extract(self, instruction: str) -> Dict[str, Any]:
        """
        æå–ç»“æ„åŒ–æ•°æ® - åŸºäº A11y Tree.
        
        ä¼˜åŠ¿: ä¸ä¾èµ–å…·ä½“ HTML ç»“æ„ï¼Œåªä¾èµ–è¯­ä¹‰å†…å®¹
        """
        if not self.initialized:
            return {"success": False, "error": "æµè§ˆå™¨æœªåˆå§‹åŒ–"}
        
        try:
            tree = await self._get_accessibility_tree()
            
            messages = [
                {"role": "system", "content": "You are a data extraction assistant. Respond with valid JSON."},
                {"role": "user", "content": f"""
ä»é¡µé¢ä¸­æå–ä¿¡æ¯.

å¯è®¿é—®æ€§æ ‘:
{tree}

æå–æŒ‡ä»¤: {instruction}

è¯·æå–å¹¶è¿”å› JSON:
{{
    "extracted": {{
        // æ ¹æ®æŒ‡ä»¤æå–çš„å­—æ®µ
    }},
    "confidence": 0.0-1.0,
    "source_description": "æ•°æ®æ¥æºæè¿°"
}}
"""}
            ]
            
            response = await self._call_llm(messages)
            
            try:
                data = json.loads(response)
            except json.JSONDecodeError:
                match = re.search(r'\{[^{}]+\}', response)
                data = {"extracted": match.group() if match else response}
            
            return {
                "success": True,
                "instruction": instruction,
                "data": data,
                "tree_version": self._tree_version,
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def observe(self, instruction: str) -> Dict[str, Any]:
        """è§‚å¯Ÿé¡µé¢å…ƒç´  - è¿”å›åŒ¹é…æŒ‡ä»¤çš„å…ƒç´ ."""
        if not self.initialized:
            return {"success": False, "error": "æµè§ˆå™¨æœªåˆå§‹åŒ–"}
        
        try:
            tree = await self._get_accessibility_tree()
            
            messages = [
                {"role": "system", "content": "You are a UI analyst. Find matching elements."},
                {"role": "user", "content": f"""
æ‰¾åˆ°åŒ¹é…æŒ‡ä»¤çš„å…ƒç´ .

å¯è®¿é—®æ€§æ ‘:
{tree}

æŒ‡ä»¤: {instruction}

è¿”å› JSON:
{{
    "matching_elements": [åŒ¹é…çš„å…ƒç´ ç´¢å¼•åˆ—è¡¨],
    "description": "é¡µé¢ç»“æ„æè¿°",
    "recommendations": ["å»ºè®®çš„æ“ä½œåˆ—è¡¨"]
}}
"""}
            ]
            
            response = await self._call_llm(messages)
            
            try:
                analysis = json.loads(response)
            except json.JSONDecodeError:
                analysis = {"description": response}
            
            return {
                "success": True,
                "instruction": instruction,
                "analysis": analysis,
                "tree": tree,
                "element_count": len(tree.split("\n")),
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def agent(self, task: str) -> Dict[str, Any]:
        """
        è‡ªä¸»ä»£ç† - å¤æ‚ä»»åŠ¡è§„åˆ’ä¸æ‰§è¡Œ.
        
        è‡ªæ„ˆèƒ½åŠ›: æ¯æ¬¡æ“ä½œå‰åˆ·æ–° A11y Tree
        """
        if not self.initialized:
            return {"success": False, "error": "æµè§ˆå™¨æœªåˆå§‹åŒ–"}
        
        try:
            results = []
            
            # åˆ†æä»»åŠ¡å¹¶è§„åˆ’æ­¥éª¤
            tree = await self._get_accessibility_tree()
            
            messages = [
                {"role": "system", "content": "You are a task planning assistant for browser automation."},
                {"role": "user", "content": f"""
å½“å‰é¡µé¢å¯è®¿é—®æ€§æ ‘:
{tree}

ä»»åŠ¡: {task}

è¯·è§„åˆ’æ‰§è¡Œæ­¥éª¤ï¼Œè¿”å› JSON:
[
    {{
        "step": 1,
        "action": "navigate|click|fill|extract|scroll|press",
        "instruction": "å…·ä½“çš„è‡ªç„¶è¯­è¨€æŒ‡ä»¤",
        "reasoning": "ä¸ºä»€ä¹ˆè¿™ä¸ªæ­¥éª¤æ˜¯å¿…è¦çš„"
    }}
]
æœ€å¤š 5 ä¸ªæ­¥éª¤ã€‚
"""}
            ]
            
            response = await self._call_llm(messages)
            
            try:
                plan = json.loads(response)
            except json.JSONDecodeError:
                match = re.search(r'\[[^\[\]]+\]', response)
                plan = json.loads(match.group()) if match else []
            
            if not isinstance(plan, list):
                return {"success": False, "error": "æ— æ³•è§£æä»»åŠ¡è®¡åˆ’"}
            
            # æ‰§è¡Œè®¡åˆ’
            for step in plan[:5]:
                step_num = step.get("step", 0)
                action = step.get("action", "")
                instruction = step.get("instruction", "")
                
                if action == "navigate" and instruction.startswith("http"):
                    result = await self.navigate(instruction)
                elif action in ["click", "hover", "fill", "scroll", "press"]:
                    result = await self.act(instruction)
                elif action == "extract":
                    result = await self.extract(instruction)
                else:
                    result = {"action": action, "message": "è·³è¿‡"}
                
                results.append({
                    "step": step_num,
                    "action": action,
                    "success": result.get("success", False),
                    "result": result,
                })
                
                # è‡ªæ„ˆ: æ¯æ¬¡æ“ä½œååˆ·æ–°æ ‘
                if action in ["click", "scroll", "navigate"]:
                    await self._get_accessibility_tree(force_refresh=True)
            
            return {
                "success": True,
                "task": task,
                "plan": plan,
                "results": results,
                "self_healing": {
                    "tree_refreshes": self._tree_version,
                    "total_steps": len(results),
                }
            }
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def close(self):
        """å…³é—­æµè§ˆå™¨."""
        if self.browser:
            await self.browser.close()
            self.initialized = False


# ============ CLI ============

async def main():
    import argparse
    
    parser = argparse.ArgumentParser(
        description="MiniMax Browser Automation V3 - Stagehand Architecture",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ç¤ºä¾‹:
  %(prog)s --test                   # æµ‹è¯• API è¿æ¥
  %(prog)s --init                  # åˆå§‹åŒ–æµè§ˆå™¨
  %(prog)s -u https://example.com  # å¯¼èˆª
  %(prog)s -a "ç‚¹å‡»ç™»å½•æŒ‰é’®"        # æ‰§è¡ŒåŠ¨ä½œ
  %(prog)s -e "æå–æ‰€æœ‰æ ‡é¢˜"         # æå–æ•°æ®
  %(prog)s --agent "å®Œæˆæ³¨å†Œ"        # è‡ªä¸»ä»£ç†
        """
    )
    parser.add_argument("--test", action="store_true", help="æµ‹è¯• API")
    parser.add_argument("--init", action="store_true", help="åˆå§‹åŒ–")
    parser.add_argument("--navigate", "-u", help="å¯¼èˆª URL")
    parser.add_argument("--act", "-a", help="æ‰§è¡ŒåŠ¨ä½œ")
    parser.add_argument("--extract", "-e", help="æå–æ•°æ®")
    parser.add_argument("--agent", help="è‡ªä¸»ä»£ç†ä»»åŠ¡")
    parser.add_argument("--observe", "-o", help="è§‚å¯Ÿé¡µé¢")
    parser.add_argument("--headed", action="store_true", help="æ˜¾ç¤ºçª—å£")
    
    args = parser.parse_args()
    
    browser = MiniMaxBrowserV3(headless=not args.headed)
    
    # æµ‹è¯•
    if args.test:
        print("=" * 60)
        print("ğŸ§ª æµ‹è¯• MiniMax API")
        print("=" * 60)
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                resp = await client.post(
                    f"{browser.api_base}/chat/completions",
                    headers={"Authorization": f"Bearer {browser.api_key}"},
                    json={"model": browser.model, "messages": [{"role": "user", "content": "hi"}], "max_tokens": 10}
                )
                print(f"âœ… API æ­£å¸¸: {resp.status_code}")
        except Exception as e:
            print(f"âŒ API é”™è¯¯: {e}")
        return
    
    # åˆå§‹åŒ–
    result = await browser.initialize()
    print(json.dumps(result, indent=2, ensure_ascii=False))
    
    if result.get("success"):
        if args.navigate:
            result = await browser.navigate(args.navigate)
            print(json.dumps(result, indent=2, ensure_ascii=False))
        elif args.act:
            result = await browser.act(args.act)
            print(json.dumps(result, indent=2, ensure_ascii=False))
        elif args.extract:
            result = await browser.extract(args.extract)
            print(json.dumps(result, indent=2, ensure_ascii=False))
        elif args.observe:
            result = await browser.observe(args.observe)
            print(json.dumps(result, indent=2, ensure_ascii=False))
        elif args.agent:
            result = await browser.agent(args.agent)
            print(json.dumps(result, indent=2, ensure_ascii=False))
    
    await browser.close()


if __name__ == "__main__":
    asyncio.run(main())
